/* ###*B*###
 * ERIKA Enterprise - a tiny RTOS for small microcontrollers
 *
 * Copyright (C) 2002-2008  Evidence Srl
 *
 * This file is part of ERIKA Enterprise.
 *
 * ERIKA Enterprise is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation, 
 * (with a special exception described below).
 *
 * Linking this code statically or dynamically with other modules is
 * making a combined work based on this code.  Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * As a special exception, the copyright holders of this library give you
 * permission to link this code with independent modules to produce an
 * executable, regardless of the license terms of these independent
 * modules, and to copy and distribute the resulting executable under
 * terms of your choice, provided that you also meet, for each linked
 * independent module, the terms and conditions of the license of that
 * module.  An independent module is a module which is not derived from
 * or based on this library.  If you modify this code, you may extend
 * this exception to your version of the code, but you are not
 * obligated to do so.  If you do not wish to do so, delete this
 * exception statement from your version.
 *
 * ERIKA Enterprise is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License version 2 for more details.
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with ERIKA Enterprise; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301 USA.
 * ###*E*### */

/*
 * Author: 2004 Paolo Gai
 * CVS: $Id: ee_ic_exc_handlers.S,v 1.8 2006/10/19 09:55:18 pj Exp $
 */

#include "cpu/arm7tdmi/inc/ee_arm7defs.h"
#include "cpu/arm7tdmi/inc/ee_compiler.h"

/*
 This file contains the ARM exception functions. UND, SWI, Prefetch
	and Data Abort are linked to an infinite loop if the
	corresponding PRIVATE define is not defined.

 The IRQ handler is then specified in this file.
	
 The FIQ handler is included into irqvect.S and it is declared as a
	macro in inc/ee_fiqstub.S.
*/


	.extern	EE_IRQ_end_instance
	
	
	// stack used by IRQ handlers
#ifdef __MULTI__
	.extern EE_arm7_hal_stkchange
#endif


	
	.extern	EE_IRQ_nesting_level

#ifdef __ALLOW_NESTED_IRQ__
// the masks used to implement priority interrupts 
#ifdef __IRQ_PRIORITY_MASKS__
	.extern EE_IC_EXTIRQ_masks
#endif	
	
#endif


	
	.extern EE_hal_endcycle_next_thread
#ifdef __MULTI__
	.extern EE_hal_endcycle_next_tos
#endif

//
// external variables declared in EE_ic.h
//

// the interrupt vector			
.extern EE_IC_EXTIRQ_vector

//
// Code area
//
	
	.text

	// kernel code is in ARM-mode
	CODE32


	/*
	 *
	 * Forever Loops
	 *
	 */

	
#ifndef __PRIVATE_UNDEFINED_HANDLER__
.global EE_UNDEFINED_handler
.type	EE_UNDEFINED_handler, #function
EE_UNDEFINED_handler:	

#ifndef YES_FOREVER_LOOP
#define YES_FOREVER_LOOP
#endif
	
#endif


#ifndef __PRIVATE_SWI_HANDLER__
.global EE_SWI_handler
.type	EE_SWI_handler, #function
EE_SWI_handler:	

#ifndef YES_FOREVER_LOOP
#define YES_FOREVER_LOOP
#endif

#endif
	

	
#ifndef __PRIVATE_PREFETCH_HANDLER__
.global EE_PREFETCH_handler
.type	EE_PREFETCH_handler, #function
EE_PREFETCH_handler:	

#ifndef YES_FOREVER_LOOP
#define YES_FOREVER_LOOP
#endif

#endif


#ifndef __PRIVATE_DATAABORT_HANDLER__
.global EE_DATAABORT_handler
.type	EE_DATAABORT_handler, #function
EE_DATAABORT_handler:	

#ifndef YES_FOREVER_LOOP
#define YES_FOREVER_LOOP
#endif

#endif


	
#ifdef YES_FOREVER_LOOP

#ifdef __NOTIFY_RUNNING_TID__
	// write tid of the task actually in stack head (running)
	LDR	r0,=__NOTIFY_RUNNING_TID__
	LDR	r1,=0xffffffff
	STR	r1, [r0]
#endif
	B .
#endif




	
	
	/*
	 *
	 * IRQ Handler
	 *
	 */

	
		
	/* Addresses of the IRQ controller for the MPARM simulator
	NOTE: it is in the text segment because it cannot be an
	immediate operand and it is constant */

EE_INT_IRQ:	.word	0x90050000
EE_INT_MSK:	.word	0x90050004
EE_INT_MOD:	.word	0x9005000c
	
	// here is an alternative for loading EE_INTSET_IRQ, generated by gcc
	// (immediate values to be used are different for MPARM)
	//mov	r1, #66846720
	//add	r0, r1, #212992
	//add	r0, r0, #52


		
	.type	EE_IRQ_handler, #function
	.global EE_IRQ_handler
EE_IRQ_handler:

	// ---------------------------------------------------------------
	// save the context inside SYS mode

	
	SUB	lr, lr, #4
	
	// save LR_IRQ, SPSR inside the IRQ stack
	STMFD	sp!,{r0-r1, lr}
	MRS	r0, spsr
	STMFD	sp!, {r0}
	MOV	r1, sp
	ADD	sp, sp, #16

	// r0 is free, r1=SP_IRQ, sp_IRQ is clean

	// switch to SYS mode
 	MOV	r0, #Mode_SYS | I_bit
 	MSR	cpsr_c, r0

	// save registers inside the user stack
	STMFD	sp!, {r2-r3, r12, lr}
	LDMFD	r1, {r0,r2,r3,r12}
	STMFD	sp!, {r0,r2,r3,r12}

	// On the user stack there are the following registers:	r2,r3, r12, lr_usr, r0, r1, lr_irq, spsr

#ifdef __NOTIFY_RUNNING_TID__
	// write tid of the task actually in stack head (running)
	LDR	r0,=__NOTIFY_RUNNING_TID__
	LDR	r1,=0xffffffff
	STR	r1, [r0]
#endif

	// ---------------------------------------------------------------
	// clear INTPND
	
	// R1 is used to address the various registers
	LDR	r1, EE_INT_IRQ
	LDR	r0, [r1]	// read the IRQ status register
	
	// CLZ (count leading zeros) instruction is available only in armv5+
	// thus now need code to find highest priority pending irq

	// r0=irq_status, r1=irq_status_address; r2, r3 free
	MOV	r2, #0
	MOV	r3, #1
IRQ_SEARCH:
	TST	r0, r3, lsl r2
	BNE	IRQ_FOUND
	ADD	r2, r2, #1
	B	IRQ_SEARCH
//	CMP	r2, #32
//	BNE	IRQ_SEARCH
//	// can never get here
//	B	.
IRQ_FOUND:

	// clear the interrupt bit from current IRQ status
	LDR	r0, [r1]	// read once again pending interrupts (to avoid losing pending interrupts)
	BIC	r0, r0, r3, lsl r2
	STR	r0, [r1]

	MOV	r2, r2, lsl #2
	// R2 contains the offset used for the vectors
	// R0, R1, R3 are free

	

	
	// ---------------------------------------------------------------
	// handle nesting and IRQ priority levels
			
#ifdef __ALLOW_NESTED_IRQ__

	// increase the nesting level
	LDR	r1, =EE_IRQ_nesting_level
	LDR	r3, [r1]
	ADD	r3, r3, #1
	STR	r3, [r1]
	
#ifdef __MULTI__
#ifdef __IRQ_STACK_NEEDED__
	// if this is the first handler instance then we have to
	// change stack
	CMP	r3, #1
	LDREQ	r0, =EE_arm7_temp_tos
	STREQ	sp, [r0]
	LDREQ	r0, =EE_arm7_IRQ_tos
	LDREQ	sp, [r0]
	
#endif
#endif
	
	// now we can re-enable interrupts
 	MOV	r1, #Mode_SYS
 	MSR	cpsr_c, r1

#ifdef __IRQ_PRIORITY_MASKS__
	LDR	r3, EE_INTMSK       // R3 now contains 4008, INTMSK
	LDR	r1, [r3]
	STMFD	sp!, {r1}           // store the old mask on the stack
	
	LDR	r1, =EE_IC_EXTIRQ_masks
	LDR	r1, [r1,r2]	    // R0 now contains the new INTMSK value

	STR	r1, [r3]	    // read the IRQ highest priority IRQ
#endif

	
#else // not __ALLOW_NESTED_IRQ__
	
	// nesting level = 1
	LDR	r1, =EE_IRQ_nesting_level
	MOV	r3, #1
	STR	r3, [r1]

	// now we can switch to SYS mode
 	MOV	r1, #Mode_SYS | I_bit
 	MSR	cpsr_c, r1
	
#endif // __ALLOW_NESTED_IRQ__



	// ---------------------------------------------------------------
	// jump to the handler
			
	
	LDR	r0, =EE_IC_EXTIRQ_vector
	LDR	r0, [r0, r2]
	// R0 contains the address of the IRQ handler
	
	// jump to the correct handler
	mov	lr,pc
	mov	pc,r0



	
	// ---------------------------------------------------------------
	// handle nesting and IRQ priority levels
	
#ifdef __ALLOW_NESTED_IRQ__
	// we can disable interrupts (_only_ IRQ, _not_ FIQ)
 	MOV	r0, #Mode_SYS | I_bit
 	MSR	cpsr_c, r0

#ifdef __IRQ_PRIORITY_MASKS__
	LDR	r1, EE_INTMSK
	LDMFD	sp!, {r0}
	STR	r0, [r1]            // set the old mask from the stack
#endif

	// decrease the nesting level
	LDR	r0, =EE_IRQ_nesting_level
	LDR	r1, [r0]
	SUB	r1, r1, #1
	STR	r1, [r0]

	// is this the first handler instance?
	CMP	r1, #0

#ifdef __MULTI__
#ifdef __IRQ_STACK_NEEDED__
	// if this is the first handler instance then we have to
	// change stack
	LDREQ	r0, =EE_arm7_temp_tos
	LDREQ	sp, [r0]
#endif
#endif
		
	// call the scheduler only if this is the first instance
	BNE	theend

#else  // not __ALLOW_NESTED_IRQ__
	
	// nesting level = 0
	LDR	r0, =EE_IRQ_nesting_level
	MOV	r1, #0
	STR	r1, [r0]
	
#endif // __ALLOW_NESTED_IRQ__

	// ---------------------------------------------------------------
	// call the scheduler
	
	// call the scheduler only if this is the first instance
	BL	EE_IRQ_end_instance


	// check if the scheduler has called IRQ_ready or IRQ_stacked
#ifdef __MULTI__
	LDR	r2, =EE_hal_endcycle_next_tos
	LDR	r1, [r2]
#endif
	
	LDR	r2, =EE_hal_endcycle_next_thread
	LDR	r0, [r2]

	CMP r0, #0 
	// now we have to call two different functions

#ifdef __MULTI__
	ADD lr, pc, #4                       // that is, theend
	BNE EE_arm7_hal_ready2stacked 
	BEQ EE_arm7_hal_stkchange
#else
	BLNE EE_arm7_hal_ready2stacked 
#endif
	
	// ---------------------------------------------------------------
	// end of the interrupt
theend:
	MOV	r1, sp
	ADD	sp, sp, #16
	LDMFD	sp!, {r2-r3, r12, lr}

	// switch to IRQ mode
 	MOV	r0, #Mode_IRQ | I_bit
 	MSR	cpsr_c, r0

	LDMFD	r1!, {r0}
	MSR	spsr, r0
	LDMFD	r1, {r0-r1,pc}^
	
	.size	EE_IRQ_handler, . - EE_IRQ_handler

	
	.end






















	
