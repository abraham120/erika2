/*************************************************************************
*
* Project: ERIKA Enterprise and Open-ZB 
*          ZigBee compliant network stack for ERIKA Enterprise
*
* Coordinators:
*   Giuseppe Lipari     <lipari@sssup.it>
*   Eduardo Tovar       <emt@dei.isep.ipp.pt>
*   Mario Alves         <mjs@isep.ipp.pt>
*
* Authors:
*   Andre Cunha            <andreribeirocunha@gmail.com>
*   Mangesh Chitnis        <m.chitnis@sssup.it>
*   Antonio Romano         <a.romano@sssup.it>
*   Ricardo Severino       <rars@isep.ipp.pt>
*   Paolo Pagano           <p.pagano@sssup.it>
*   Christian Nastasi      <nastasichr@gmail.com>
*
* ReTiS Lab (CEIIC, Scuola Superiore S.Anna - Pisa - Italy)
* IPP-Hurray (Polytechnique Institute of Porto - Portugal)
*
* http://retis.sssup.it
* http://www.hurray.isep.ipp.pt
*
*************************************************************************
*
* Copyright (C) 2008 Andre Cunha, Mangesh Chitnis 
*                    Antonio Romano, Ricardo Severino
*                    Paolo Pagano, Christian Nastasi
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*
*************************************************************************
*
* CVS: 
*
* $Id: Nwl.c,v 1.16 2008/07/30 16:47:20 chris Exp $
* $Log: Nwl.c,v $
* Revision 1.16  2008/07/30 16:47:20  chris
* Use precompiler define (optional) to specify radio channels; Add sync-to-beacon callback pointer
*
* Revision 1.15  2008/07/15 17:49:35  chris
* Update comments
*
* Revision 1.14  2008/07/11 15:02:53  chris
* Remove extern for I_AM_IN_CAP
*
* Revision 1.13  2008/07/08 18:20:05  chris
* BUG-FIX: checking return value for queue functions which was 0 ad put into a pointer (insertq, getq, removeq)
*
* Revision 1.12  2008/07/04 13:29:56  chris
* BUG-FIX: Remove bad check (I_AM_IN_CAP) in the openZB_send_* functions
*
* Revision 1.11  2008/07/04 09:47:25  chris
* INFO: Add commented header (project description, licence, people) to files.
*
*
*************************************************************************/

#define _Nwl_c_

/*
 * 
 * NWL Layer Main Implementation file
 * 
 * 
 */
#include "nwl/Nwl.h"
#include "hal/hal_interrupts.h"

//metrics
//total bytes send by the application
EE_UINT32 total_bytes_send_app = 0;
//total bytes effectivelly sent by MAC on a successfull CSMA/CA attemp
EE_UINT32 total_bytes_send_mac = 0;
//total packets generated by the application
EE_UINT16 packet_count_app = 0;
//total packets effectivelly sent by MAC
EE_UINT16 packet_count_mac = 0;
//number of failed CSMA CA attemps - in packet count
EE_UINT16 packet_csmaca_fail =0;

volatile void (*_openZB_rx_callback) 	(OpenZB_ExitStatus, EE_UINT8*, EE_UINT16) = NULL;
volatile void (*_openZB_err_callback) 	(OpenZB_ExitStatus) = NULL;
volatile void (*_openZB_sync_callback) 	(OpenZB_ExitStatus) = NULL;

volatile OpenZB_DebugInfo 	_openZB_debug_stats;

OpenZB_ExitStatus openZB_init(void (*rx_callback) (OpenZB_ExitStatus, EE_UINT8*, EE_UINT16), void (*err_callback) (OpenZB_ExitStatus))
{
	/* Init CallBack Functions */
	/* TODO: Check if and how disable RX by means of rx_callback NULL */
	_openZB_rx_callback 	= rx_callback;		/* Select an receive callback function */
	_openZB_err_callback 	= err_callback;		/* Select an error callback function */

	#ifdef OPENZB_DEBUG
	/* Init Debug Information */
	_openZB_debug_stats.received_beacon_packets = 0;	
	_openZB_debug_stats.received_data_packets = 0;	
	_openZB_debug_stats.received_ack_packets = 0;	
	_openZB_debug_stats.received_command_packets = 0;	
	_openZB_debug_stats.received_invalid_packets = 0;	
	#endif


	/* TODO: does never fail? */
	init_mac();					/* Starting the MAC Layer */

	#ifndef OPENZB_CHANNEL
	#define OPENZB_CHANNEL 26
	#endif

	#ifdef DEVICE_TYPE_COORDINATOR 
	/* TODO: never fails? */
	MLME_START_request(0x1234, OPENZB_CHANNEL, 4,4,1,0,0,0,0);	/* Starting the coordinator */
	#else
	/* TODO: never fails? */
	MLME_ASSOCIATE_request(OPENZB_CHANNEL,0,0x1234,0,0,0);		/* Starting the device */
	#endif

	return OPENZB_SUCCESS;
}

/* TODO: make inline function */
OpenZB_ExitStatus openZB_get_debug_info(OpenZB_DebugInfo* stats)
{ 
	/* TODO: lock on semaphore! */
	memcpy(stats, &_openZB_debug_stats, sizeof(OpenZB_DebugInfo)); 
	return OPENZB_SUCCESS;
}

OpenZB_ExitStatus openZB_send_bytes(const EE_UINT8 *data, EE_UINT16 size, EE_UINT8 use_gts)
{
	EE_UINT32 SrcAddr[2];
	EE_UINT32 DestinationAddr[2];
	
	SrcAddr[0]=0x00000000;
	SrcAddr[1]=0x00000001;
	
	DestinationAddr[0]=0x00000000;
	DestinationAddr[1]=0x0000FFFF;

	MCPS_DATA_request(SHORT_ADDRESS, 0x1234, SrcAddr, SHORT_ADDRESS, 0x1234, DestinationAddr, size, data,1,set_txoptions(0,use_gts,0,0));

	return OPENZB_SUCCESS;
}

OpenZB_ExitStatus openZB_send_string(const char *str, EE_UINT8 use_gts)
{
	
	EE_UINT32 SrcAddr[2];
	EE_UINT32 DestinationAddr[2];
	
	SrcAddr[0]=0x00000000;
	SrcAddr[1]=0x00000001;
	
	DestinationAddr[0]=0x00000000;
	DestinationAddr[1]=0x0000FFFF;
	
	int length = strlen(str);
	
	MCPS_DATA_request(SHORT_ADDRESS, 0x1234, SrcAddr, SHORT_ADDRESS, 0x1234, DestinationAddr, length, str,1,set_txoptions(0,use_gts,0,0));
	
	return OPENZB_SUCCESS;
}

void NW_RECEIVE_DATA(EE_UINT16 length, char *data)
{
	if(_openZB_rx_callback)
		_openZB_rx_callback(OPENZB_SUCCESS, data, length);
}



/****************************************************************/
/****************************************************************/
/****************************************************************/
/*					MAC CALLBACK FUNCTIONS   					*/
/****************************************************************/
/****************************************************************/
/****************************************************************/
/***************************************************************/
/*						MLME_BEACON_NOTIFY EVENTS							*/
/*****************************************************************/
EE_UINT8 MLME_BEACON_NOTIFY_indication(EE_UINT8 BSN,PANDescriptor pan_descriptor, EE_UINT8 PenAddrSpec, EE_UINT8 AddrList, EE_UINT8 sduLength, EE_UINT8 sdu[])
{



return 1;
}

/***************************************************************/
/*						MLME_START EVENTS							*/
/*****************************************************************/
EE_UINT8 MLME_START_confirm(EE_UINT8 status)
{

return 1;
}
/****************************************************************/
/*						MCPS_DATA EVENTS						*/
/*****************************************************************/
EE_UINT8 MCPS_DATA_confirm(EE_UINT8 msduHandle, EE_UINT8 status)
{

return 1;
}

EE_UINT8 MCPS_DATA_indication(EE_UINT16 SrcAddrMode, EE_UINT16 SrcPANId, EE_UINT32 SrcAddr[2], EE_UINT16 DstAddrMode, EE_UINT16 DestPANId, EE_UINT32 DstAddr[2], EE_UINT16 msduLength,EE_UINT8 msdu[100],EE_UINT16 mpduLinkQuality, EE_UINT16 SecurityUse, EE_UINT16 ACLEntry)  
{
	NW_RECEIVE_DATA(msduLength, msdu);
	return 1;
}




