/**
 * @file
 * This file implements the MLME-POLL.request (MAC layer management entity)
 * entry points.
 *
 * $Id: poll.c,v 1.1 2007/06/22 13:50:48 romano Exp $
 */
/**
 *  \author
 *      Atmel Corporation: http://www.atmel.com
 *      Support email: avr@atmel.com
 */
/*
 * Copyright (c) 2006, Atmel Corporation All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name of ATMEL may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
 * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* === Includes ============================================================ */
#ifndef DEF_H
#include "def.h"
#endif

#include <stdlib.h>
#include "phy.h"
#include "mac.h"
#include "timer_const.h"

#if APP_TYPE >= APP_L2 || defined(DOXGEN)

/* === Globals ============================================================= */

/* === Prototypes ========================================================== */

/* === Implementation ====================================================== */

/*
 * Internal function to initiate mlme poll confirm message
 */
static void gen_mlme_poll_conf(uint8_t status)
{
    mlme_poll_conf_t mpc;

    mpc.cmdcode = MLME_POLL_CONFIRM;
    mpc.size = sizeof(mlme_poll_conf_t) - sizeof(mpc.size);
    mpc.status = status;
    bios_pushback_event((uint8_t *)&mpc);
}

/**
 * \brief Implement MLME-POLL.request
 *
 * The MLME-POLL.request primitive is generated by the next higher layer and issued to its MLME when
 * data are to be requested from a coordinator.
 *
 * @param m Pointer to the message
 */
void mlme_poll_request(uint8_t *m)
{
    mac_original_state = mac_state;

    if ((mac_state == MAC_A) || (mac_state == MAC_Tracking_Beacon))
    {
        // Build command frame due to explicit poll request
        mac_build_data_req_cmd(true, false);
    }
    else
    {
        gen_mlme_poll_conf(MAC_CHANNEL_ACCESS_FAILURE);
    }
}

/**
 * \brief T_MaxFrameResponseTime timer callback
 *
 * This function implements the T_MaxFrameResponseTime timer callback. If a poll request is pending,
 * a mlme-poll-confirm is generated. The mac state is set to mac_pre_csmaca_state.
 * No data is returned on poll request.
 */
void mac_t_maxframeresponsetime(void)
{
    if (mac_state == MAC_H)
    {
        gen_mlme_poll_conf(MAC_NO_DATA);
    }

    if ((mac_state == MAC_H) || (mac_state == MAC_await_frame))
    {
        mac_state = mac_pre_csmaca_state;
    }

}

/**
 * \brief process a data response to an MLME-POLL.request
 *
 * In response to an MLME-POLL.request, our coordinator responded with
 * a frame.  See whether we've got any data, and construct the
 * appropriate MLME-POLL.confirm message.
 */
void mac_process_data_response(void)
{
    mlme_poll_conf_t mpc;

    mpc.size = sizeof(mpc) - sizeof(mpc.size);
    mpc.cmdcode = MLME_POLL_CONFIRM;
    switch (mac_parse_data.frame_type)
    {
    case FCF_FRAMETYPE_MAC_CMD:
        mpc.status = MAC_NO_DATA;
        bios_pushback_event((uint8_t *)&mpc);
        break;

    case FCF_FRAMETYPE_DATA:
        if (mac_parse_data.payload_length > 0)
        {
            mpc.status = MAC_SUCCESS;
            /* MCPS-DATA.indication is generated in mac_proc_pd_data_ind() */
        }
        else
        {
            mpc.status = MAC_NO_DATA;
        }
        bios_pushback_event((uint8_t *)&mpc);
        break;

    default:
        /* unexpected frame type, discard */
        return;
    }
    bios_stoptimer(T_MaxFrameResponseTime);
    mac_state = mac_pre_csmaca_state;
}

#endif /* APP_TYPE >= APP_L2 || defined(DOXYGEN)*/

/* EOF */
